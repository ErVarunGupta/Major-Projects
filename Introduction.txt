============================================
Getting Started:
----------------------------
*Database Set Up
*REST Apis for CRUD

-------------------------
Model: Listing
->title
->description
->image
->price
->location
->country

====================================
For styling :
EJS Mate:

================================================================


**Form Validations:
->When we enter data in the form, the browser and/or the web server will check to see that the data is in the correct formate and within the contains set by the application.
*Client side Validations
*Server side Validations

*Success and failure Validations:

novalidation" white in form and make class = "needs-Validations"
<div class="invalid-feedback">Please enter the valid location</div>

-------------------------------------------------------------
Server side validations:
Custom Error Handler:

*Use Joi -> which is used for validate schema

======================================================
*New Model: Reviews
comment
rating(1 to 5)
createdAt

*Deleting Reviews:
(Mongo $pull operator)
->$pull: > The $pull operator removes from an existing array all instance of a value or value that match a specified condition.


==========================================================
{51:] 
*Express Router:
(Restructing Listings)
-> app.use("/listings",listings);

Restructing Reviews:
app.use("/listings/:id/reviews",reviews);
router = express.Router({mergeParams: true});

/listings/:id/reviews => parent router
/ or /:reviewId => child route

**Miscellaneous:
*Express Router
->Express Routers are a way to organize your Express application such that our primary app.js file
 does not become bloated.
->const router = express.Router() //creates new router object

*Cookies:
-> HTTP cookies are small blocks of data created by a web server while a user is browsing a website
  and placed ont the user's computer or ther device by the user's web browser.

======================================================
{52:)
**What is State?
*Statefult Protocol
->Stateful Protocol require server to save the status and session information.
eg: ftp(file transfer Protocol)

*Stateless Protocol:
-> Stateless Protocol does not require the server to retain the server information or
eg: http

*Express Sessions:
->An attempt to make our session stateful
app.get("/reqcount",(req, res)=>{
//     if(req.session.count){
//         req.session.count++;
//     }else{
//         req.session.count = 1;
//     }
//     res.send(`You sent a request ${req.session.count} times.`);
// })

// app.get("/test",(req, res)=>{
//     res.send("test successful!");
// })
--------------------------------------------------------
*connect flash:
->The flash is  a special area of the session used for storing messages.Messages are written 
 to the flash and cleared after being displayed to the user.


=======================================================
======================================================
|| Let's Understand ||
*Authentication:
->Authentication is the process of verifying who someone is

*Authorization:
->Authorization is the process of verifying what specific applications, files, and data a user has access to


||Storing Passwords||
->We NEVER store the Passwords as it is. We store their hashed form.

||Hashing||
:What we need to know?
->For every input, there is a fixed output
->They are one-way functions, we can't get input from output
->For a different input, there is a different output but of same length
->Small changes in input should bring large changes in output

||Salting||
->Password salting is a technique to protect passwords stored in databases by adding a string of 32 or more characters and then hashing them.

npm i passport passport-local passport-local-mongoose

||pbkdf2 hashing algorithm is used by passport-local-mongoose

------------------------------------------
||Configuring Strategy||
*passport.initialize():
->A middleware that initializes passport.

*passport.session():
-> A web application needs the ability to identify users as they browse from page to page.
This series of requests and responses, each associated with the same user, is known as a session.

passport.use(new LocalStrategy(User.authenticate()))

=================================================
||Signup User||
: GET /signup
: POST /signup

-----------------------------------------------
Connectiong Login Route:
->req.isAuthenticated() //passport method

module.exports.isLoggedIn = (req, res, next)=>{
    if(!req.isAuthenticated()){
        req.flash("error","You must be logged in to create listing!");
        return res.redirect("/login");
    }
    next();
}

-----------------------
||Logout User||
GET /logout

router.get("/logout",(req, res, next)=>{
    req.logout((err)=>{
        if(err){
            return next(err);
        }
        req.flash("success","you are logged out!");
        res.redirect("/listings");
    })
})

-------------------------
Login after SignUp||
->Passport's login method automatically establishes a login session.
->We can invoke login to automatically login a user.

===============================================================
{We Implement a full stack project using MVC framwork]
PHASE - 3: Part (a):
=========================================================
||MVC : Model, View, Controller||
-> Implement Design Pattern for Listings
->Implement Design Pattern for Review & Users
---------------------------------------------------
||Image Upload||
*Manipulate form:

<div class="mb-3">
    <label for="image" class="form-label">Upload Listing Image</label>
    <input name="listing[image]" type="file" class="form-control"/>
</div>
->enctype="multipart/form-data"
->npm i multer
const multer = require('multer');
const upload = multer({dest: 'uploads/'})
.post(upload.single('listing[image]'),(req, res)=>{
        res.send(req.file)
    })

----------------------------------------------------------
||Coud Setup||
->Cloudinary & .env file

||Store Files||
Multer Store Cloudinary
npm i cloudinary multer-storage-cloudinary

||When npm error: npm config set legacy-peer-deps true||

------------------------------------------------------
||Save Link in Mongo||
previous schema
image: {
    type: String,
    default: defaultImage,
    set:(v) => (v==="" ? defaultImage : v),
  },
modify image in schema

====================================================

API_KEY=AIzaSyCwWmramd7oviubzq2f8gj4yWY29gzxr6U

||Geocoding||
->Geocoding is the process of converting address (like a street address) into geographic coordinates
(like latitude and longitude), which you can use to place markers on a map, or position the map.

//forward geocoding
https://maps.googleapis.com/maps/api/geocode/json?address=1045%20E%2024th%20St,%20Minneapolis,%20MN%2055404&key=AIzaSyCwWmramd7oviubzq2f8gj4yWY29gzxr6U


===========================================================
||DEPLOY||
||Mongo Atlas||
->Cloud Database Service
Database.Deploy a multi-cloud database.

Username: varungupta0994
pass: uiNtQNtgSPIUfU8W

database Link:
mongodb+srv://varungupta0994:<db_password>@cluster0.vr8vd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
ATLASDB_URL = mongodb+srv://varungupta0994:uiNtQNtgSPIUfU8W@cluster0.vr8vd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

const dbUrl = process.env.ATLASDB_URL;

main()
.then(()=>{console.log("Connected to DB")})
.catch((err)=>{console.log(err)});

async function main(){
    await mongoose.connect(dbUrl);
}
-------------------------------------------------------------

||Mongo Session Store||
npm i connect-mongo
/deploy part
const store = MongoStore.create({
    mongoUrl: dbUrl,
    crypto:{
        secret: "mysupersecretstring",
    },
    touchAfter: 24*60*60,
})

store.on('error',(err)=>{
    console.log("ERROR in MONGO SESSION STORE", err)
})

||Deployment||
*render
*netlify
*cyclic etc.

||Connect render with Github||
git init
touch .gitignore
git add .
git commit -m "Add Projects Files"
